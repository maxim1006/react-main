### sliding window 
O(n)
Идея метода скользящего окна состоит в том, чтобы эффективно найти «лучшее» окно, которое соответствует некоторому ограничению. Обычно описание проблемы определяет, что делает окно «лучше» (меньшая длина, большая сумма и т. д.), а также ограничения. Представьте, что задача требует длины самого длинного подмассива с суммой, меньшей или равной k для массива с положительными числами. В этом случае ограничение равно sum(window) <= k, и чем длиннее окно, тем оно лучше. Общий алгоритм скользящего окна:

1 Определите указатель для левой и правой границ, которые представляют текущее окно, обычно оба они начинаются с 0.
2 Перебрать массив с правой границей, чтобы «добавить» элементы в окно.
3 Всякий раз, когда ограничение нарушается, в этом примере, если сумма окна превышает k, тогда «удаляются» элементы из окна, увеличивая левую границу до тех пор, пока условие снова не будет выполнено.
Вот некоторый псевдокод, иллюстрирующий концепцию:

pseudocode
```
function fn(arr):
    left = 0
    right = arr.length - 1

    while left < right:
        Do some logic here depending on the problem
        Do some more logic here to decide on one of the following:
            1. left++
            2. right--
            3. Both left++ and right--
```

В нашем примере «сумма меньше k» мы можем использовать переменную curr, которая отслеживает текущую сумму окна. Таким образом, мы знаем, когда сумма превышает k, без необходимости вычислять сумму окна с нуля на каждой итерации. Мы можем «добавить» элементы, выполнив команду curr += arr[right], и «удалить» элементы, выполнив команду curr -= arr[left]. Данные и логика, необходимые для хранения информации об окне, будут различаться в зависимости от задачи.

