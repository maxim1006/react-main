### sliding window 
O(n)
Идея метода скользящего окна состоит в том, чтобы эффективно найти «лучшее» окно, которое соответствует некоторому ограничению. Обычно описание проблемы определяет, что делает окно «лучше» (меньшая длина, большая сумма и т. д.), а также ограничения. Представьте, что задача требует длины самого длинного подмассива с суммой, меньшей или равной k для массива с положительными числами. В этом случае ограничение равно sum(window) <= k, и чем длиннее окно, тем оно лучше. Общий алгоритм скользящего окна:

1 Определите указатель для левой и правой границ, которые представляют текущее окно, обычно оба они начинаются с 0.
2 Перебрать массив с правой границей, чтобы «добавить» элементы в окно.
3 Всякий раз, когда ограничение нарушается, в этом примере, если сумма окна превышает k, тогда «удаляются» элементы из окна, увеличивая левую границу до тех пор, пока условие снова не будет выполнено.
Вот некоторый псевдокод, иллюстрирующий концепцию:

pseudocode
```
function fn(arr):
    left = 0
    for right in [0, arr.length - 1]:
        Do some logic to "add" element at arr[right] to window

        while left < right AND condition from problem not met:
            Do some logic to "remove" element at arr[left] from window
            left++

        Do some logic to update the answer
```

В нашем примере «сумма меньше k» мы можем использовать переменную curr, которая отслеживает текущую сумму окна. Таким образом, мы знаем, когда сумма превышает k, без необходимости вычислять сумму окна с нуля на каждой итерации. Мы можем «добавить» элементы, выполнив команду curr += arr[right], и «удалить» элементы, выполнив команду curr -= arr[left]. Данные и логика, необходимые для хранения информации об окне, будут различаться в зависимости от задачи.

Если в задаче требуется количество подмассивов, соответствующих некоторому ограничению, мы все равно можем использовать скользящее окно, но нам нужно использовать изящный математический трюк, чтобы вычислить количество подмассивов.

### посчитать количество подмассивов
Основная идея: Всякий раз, когда вы сталкиваетесь с проблемой, требующей количества подмассивов, подумайте об этом: в каждом индексе, сколько допустимых подмассивов заканчивается этим индексом? Давайте разделим 8 подмассивов по их конечным индексам:
Если задача: Учитывая массив положительных целых чисел nums и целое число k, вернуть количество смежных подмассивов, где произведение всех элементов в подмассиве строго меньше, чем k.
nums = [10, 5, 2, 6], k = 100 
то все массивы
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]

[10] (1)
[5], [10, 5] (1 - 0 + 1)
[2], [5, 2] (2 - 1 + 1) (-1 это left уменьшаю окно)
[6], [2, 6], [5, 2, 6] (3 - 1 + 1)

получается что для каждого индекса right - left + 1 


### Fixed window size
В примерах, которые мы рассмотрели выше, размер нашего окна был переменным. Мы пытались расширить его настолько, насколько могли, сохраняя при этом окно в пределах некоторого ограничения, и удаляли элементы слева, когда оно нарушало ограничение. Иногда в задаче указывается фиксированная длина подмассива. Эти вопросы просты, потому что критерии обычно одни и те же — просто убедитесь, что размер окна остается прежним. Чтобы построить начальное окно (от индекса 0 до k - 1), вы можете либо построить его вне основного цикла, либо вы можете использовать логику внутри вашего основного цикла, чтобы рассматривать окно для ответа только после того, как оно достигнет размера k. Вот некоторый псевдокод для обоих методов:

```js
// first approach
function fn(arr, k):
curr = some data type to track the window

    // build the first window
    for i in [0, k - 1]:
        Do something with curr or other variables to build first window

    ans = answer variable, might be equal to curr here depending on the problem
    for i in [k, arr.length - 1]:
        Add arr[i] to window
        Remove arr[i - k] from window
        Update ans

    return ans
```
