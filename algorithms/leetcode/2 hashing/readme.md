### Hash-map (в js просто объекты или new Map();)
Мы знаем, что arrays (массивы) имеют произвольный доступ O(1). Основное ограничение массивов заключается в том, что они имеют фиксированный размер, а их индексы должны быть целыми числами. Поскольку хеш-функции могут преобразовывать любые входные данные в целое число, если мы объединим массив с хеш-функцией, мы можем создать так называемую hash map, также известную как hash table or dictionary. Тогда у нас может быть случайный доступ O(1) к массиву без ограничения целых чисел в качестве индексов. С массивами мы сопоставляем индексы со значениями. С помощью хэш-карт мы сопоставляем ключи со значениями, а ключ может быть практически любым. Как правило, единственным ограничением для ключа хеш-карты является то, что он должен быть неизменным (immutable) (это зависит от языка, но в целом является хорошим практическим правилом). Ц

Подводя итог, можно сказать, что хэш-карта — это неупорядоченная структура данных, в которой хранятся пары ключ-значение. Хэш-карта может добавлять и удалять элементы в O(1), а также обновлять значения, связанные с ключом, и проверять, существует ли ключ, также в O(1). Вы можете перебирать как ключи, так и значения хэш-карты, но хэш-карта не обязательно является упорядоченной структурой данных (существует много реализаций, и это зависит от языка для встроенных типов).

С точки зрения временной сложности, хеш-карты круче массивов. Все следующие операции
O(1) для хеш-карты:

- Добавьте элемент и свяжите его со значением
- Удалить элемент, если он существует
- Проверить, существует ли элемент

Хэш-карта также имеет многие из тех же полезных свойств, что и массив с той же временной сложностью (O(n)):

Найти длину/количество элементов
Обновление значений
Перебирать элементы

Самым большим недостатком хеш-карт является то, что при меньших размерах входных данных они могут работать медленнее из-за накладных расходов. Поскольку большой O игнорирует константы, временная сложность O(1) иногда может быть обманчивой — обычно это больше похоже на O(10), потому что каждый ключ должен пройти через хеш-функцию, а также могут быть коллизии, о которых мы поговорим. в следующем разделе.

Хеш-таблицы также могут занимать больше места. Напомним, что динамические массивы на самом деле представляют собой массивы фиксированного размера, которые изменяют свой размер, когда выходят за пределы своей емкости. Хэш-таблицы также реализованы с использованием массива фиксированного размера — помните, что размер — это ограничение, установленное программистом. Проблема в том, что изменение размера хеш-таблицы обходится намного дороже, потому что каждый существующий ключ необходимо повторно хешировать, а также хеш-таблица может использовать массив, который значительно больше, чем количество хранимых элементов, что приводит к огромной трате места. . Допустим, вы выбрали ограничение в 10 000 элементов, но в итоге вы храните только 10. Хорошо, вы можете возразить, что 10 000 — это слишком много, но что, если вашему следующему тестовому сценарию потребуется хранить 100 000 элементов? Дело в том, что когда вы не знаете, сколько элементов вам нужно хранить, массивы более гибки с изменением размера и не тратят место впустую.


### Set (набор)
Набор — это еще одна структура данных, очень похожая на хеш-таблицу. Он использует тот же механизм для преобразования ключей в целые числа. Разница между набором и хеш-таблицей заключается в том, что наборы не сопоставляют свои ключи ни с чем. Наборы более удобны в использовании, когда вы заботитесь только о проверке существования элементов. Вы можете добавлять, удалять и проверять, существует ли элемент в наборе, и все это за O (1).


```js
Object.fromEntries(new Map([["a", 1]])); // {a: 1}

let map = new Map(Object.entries({a: 1}));

map.has("a"); // true

for (let [key, value] of map) {
    console.log(key, value); // a 1
}
```
