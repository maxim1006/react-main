### Frequency problems
- посчитать вхождения и сравнить их в 2х массивах / строках
- сравнить строки / массивы
Обычно на вход подаются 2 массива и стандартным решением является превратить по какому-то условию их в объекты и сравнить
   
### [two pointers](./patterns/two-pointers.md)

### Multiple pointers
- найти элементы в массиве/строке которые при сложении дают например 0
К примеру задача найти индексы элементов в массиве которые в сумме дают число.
Создаю стор, складываю туда элементы по какому-то условию, например число - текущий элемент, затем продолжаю цикл и ищу в оставшихся числах элемент стора. и if (i in store) то возвращаю что нужно из стора и текущий элемент/индекс
Если массив отсортирован то в случае нахождения суммы могу сравнивать начало и конец и while(left < right) искать парами числа и уменьшать range
  
### Sliding window
- найти максимальную последовательность уникальных символов в строке
- найти последовательность с максимальной суммой в массиве 
Создаю окно, которое может быть массивом или суммой элементов в массиве. Дальше передвигаю окно, если рассматривать сумму то прибавляю следующий айтем и вычитаю первый, тем самым передвигаю окно, в темп складываю сумму и сравниваю с ней новую сумму при передвижении окна

### превратить строку, посчитать отрезки и тд
Сперва делаю луп начиная со 2го элементы, первый запоминаю в прив. Далее каждый послудующий сравниваю с прив по какому-то условию. После луп также нужно обработать последний элемент
   
### Linked Lists
Создаю инишиал лист и вспомогательную ссылку на list (именно на лист!!! обычно temp), потом в цикле while прохожусь по всем next как temp = list.next; не забываю после while обработать конечные условия. С помощью temp меняю/модифицирую list.next и возвращаю list.next
Если нужно стартовать с 1ой вершины и менять ее let res = new ListNode(0, head); а возвращать res.next

### Recursions
Invoke the same function until u reach your base case (the condition when recursion ends) passing different inputs
Обязательно нужен base case (условие при котором прекращаю рекурсию) и возвращаемое value из функции иначе получу stack overflow (Maximum call stack exceed)

Когда нам надо наполнить рекурсивно какой-нибудь массив обычно используют helper method recursion
function outer(input) {
    let arr = [];
    function helper() {...}
    helper(input);
    return arr;
}
