### O
n ** m - n raised to the m power (or: n to the m) (or: n to the power of 2)
n * m - n times m
m ^ 2 - m squared
On the order of - the worst case scenario of algorithm. В процессе его вычислений достаточно много допущений, к примеру n^2 + 2n + 1 === O(n^2), или n - 1 === O(n) // где n - количество операций за который алгоритм приходит к финальному результату причем указывается всегда наихудшая ситуация

O(n^2) - bubble sort, selection sort 
O(n log n) - quick sort
O(n) - linear search
O(log n) - binary search (на отсортированном массиве) (logarithm of n)
O(1) - constant time

### division
numerator / denominator = fraction

### multiply
multiplier / multiplicand = product

### Ω (omega)
Best case scenario (omega of 1 - linear search)

Ω(n^2) - bubble sort (без условия что если swap = false остановись), selection sort
Ω(n log n) - merge sort
Ω(n) - bubble sort (c условием что если swap = false, те прошли один раз по массиву и ничего не поменяли, это индикатор чтобы остановить сортировку)
Ω(log n) 
Ω(1) - linear search, binary search



## SEARCH

### linear search O(n)
O(n) (On the order of n - efficiency of the algorithm )

Причем на бесконечном пространстве O(n) === O(n/2) (когда 2 числа за 1 раз например ищем) === O(n)

В лучшем случае мы найдем за 1 операцию в худшем за n

### binary search O(log n)
Работает быстрее чем линейный поиск но подразумевается что массив **отсортирован** по порядку (хорошая аналогия такого поиска орфографический словарь, если ищу букву то открываю посередине и тд)
делением попалам
сложность поиска по отсортированному массиву быстрее чем за линейное время:
O(log n)



## SORT

### selection sort (сортировка выбором) - O(n^2)
Есть массив неупорядоченных элементов, В двойном цикле сперва берем айтем, затем во втором цикле сравниваем с остальными и находим минимальный, меняем их местами с элементом из первого цикла если меньше, затем снова пробегаемся по массиву и меняем минимальное значение уже со вторым элементом и тд

В массиве 26 элементов и проходим за 325 итерация

получается что O(1/2*n^2) отбрасываю 1/2 получаю O(n^2)

### bubble sort - O(n^2)
В двойном цикле пробегаемся по массиву и сравниваем соседние элементы, если следующий элемент меньше чем предыдущий то меняем местами, получается своего рода всплытие
сортировка пузырьком 

### Quick sort (Hoare sort) - O(n * log n)
Принцип разделяй и власвуй. Рекурсивной функцией делим массив на подмассивы и каждый раз рекурсивно выбираем опорный элемент, чаще всего центральный, пробегаемся по массиву и все элементы который больше добавляем в 1 массив а те которые меньше в другой массив, для каждого из полученных массивов выполняю туже операцию и так делаю до тех пор пока длинна массива не равна 1, что и будет базовым условием для выхода из рекурсии. Затем полученные массивы склеиваются в 1 большой.

### recursion
это функция которая вызывает сама себя, должна иметь условие при котором вызов функции прекращается иначе будет бесконечный вызов

Фунцкия **fibonacci** 
O(2^n) - time complexity
O(n) - space complexity

### Stack (push/pop)
LIFO (последний кто подошел выйдет первый)
Элементы всегда добавляются в конец структуры и извлекаются также из конца (как пример стопка книг или тарелок)

### Queue (push, shift)
FIFO (первый кто подошел первый и выйдет)
В очереди элементы всегда вставляются в конец структуры, а извлекаются из ее начала (как очередь на кассу) 
FIFO - first in first out - первый вошел первый вышел

### Object
Insertion O(1)
Removal O(1)
Search O(n)
Access O(1)

### Array
Отличительная особенность массива в том что он занимает конкретный участок в памяти и изначально определено сколько элементов в нем будет находиться
+ мы знаем позицию каждого элемента и можем получить его за константное время (мгновенно)
- чтобы добавить элемент в массив приходится создавать новый массив на одну ячейку больше, перекидывать туда значения старого массива, добавлять новый элемент и удалять старый массив

O(1) - получение элемента
O(n) - добавить/удалить элемент
O(n) - поиск

O(N**log N) sort

### Linked List
Каждый отдельно взятый элемент списка занимает отдельное место в памяти. Каждый элемент хранит ссылку на след элемент который лежит в списке
Similar to array, but instead of indexes and positions, linked list points to the next or/and previous item in the list.

O(1) - добавить/удалить в начало/конец/если знаем место
O(n) - добавить/удалить элемент в произвольном месте если не знаем места
O(n) - поиск

+ Insertion is very quick (очень быстрая вставка элементов в начало/конец/если знаем место)
- Get individual element on the specific index - much slower than an array. (чтобы найти какой-то элемент надо итерироваться до него с самого начала списка)

Массив подходит для случаев где нечасто нужно изменять размер массива и часто обращаться к данным. Список подходит в том случае если мы редко обращаемся к данным и часто его пополняем

### tree
Дерево - это рекурсивная структура данных где каждый узел также является деревом

### Бинарное дерево
Это структура данных где каждый узел также является деревом, те структура рекурсивна и у каждого узла может быть только 2 потомка. Добавляются узлы особым способом, если добавляемое в дерево значение меньше чем текущий угол то значение уходит в левое поддерево, если больше то в правое, сравнение происходит с каждым узлом и получается что правая часть поддерева выстраивается с большими значениями, а левая с меньшими
O(log2n) - вставка/удаление
O(log2n) - поиск

### словарь, карта, map
За константное время добавляем и извлекаем значения (как в объекте)

### set 
Хранит только уникальные значения

### grid
Любое передвижение по матрице m*n можно разложить на дерево, так как двигаться можем только вправо или вниз
O(2^(n+m)) - time complexity
O(n+m) - space complexity
O(m*n) - time complexity memoized

### tabulation 
Техника при которой итеративно (не рекурсивно) строю таблицу с длинной на 1 больше чем размер входящих данных. К примеру fib(6) создаю массив от 0 до 6. В итоге стараюсь заполнить эту таблицу результатом конкретной итерации алгоритма. Так как мы знаем что итерируемся по массиву длинны n, то time complexity O(n), space O(n)
Recipe:
1) Представить проблему в виде таблицы / матрицы
2) в зависимости от входных данных построить матрицу
3) инициализировать дефолтные значения
4) вписать в таблицу тривиальный (100% правильный и понятный на начальном этапе) ответ
5) проитерироваться по таблице
6) заполнить остальные ячейки по определенной логике 


